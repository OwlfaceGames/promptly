# allows cmd substitution in prompt
setopt prompt_subst

# ─────────────────────────────────────────────────────────────
# Lambda prompt character
# ─────────────────────────────────────────────────────────────
PROMPT_CHAR="❯"

# Define Nerd Font symbols with explicit Unicode values
AHEAD_ICON=$'\uf176'     # Arrow up (ahead)
BEHIND_ICON=$'\uf175'    # Arrow down (behind)
DIVERGED_ICON=$'\uf7a5'  # Up/down arrows (diverged)
STAGED_ICON=$'+'         # Plus symbol (staged)
UNSTAGED_ICON=$'!'       # Exclamation symbol (unstaged)
UNTRACKED_ICON=$'?'      # Question mark symbol (untracked)
STASHED_ICON=$'$'        # Archive/box symbol (stashed)

# ─────────────────────────────────────────────────────────────
# Git info function with text labels instead of icons
# ─────────────────────────────────────────────────────────────
git_prompt_info() {
  git rev-parse --git-dir > /dev/null 2>&1 || return

  local branch=$(git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --exact-match 2>/dev/null || echo "DETACHED")
  
  # Single git status call with branch info
  local git_status_raw=$(git status --porcelain -b 2>/dev/null)
  
  # Parse status more efficiently
  local staged=0 unstaged=0 untracked=0
  while IFS= read -r line; do
    case "${line:0:2}" in
      "##") continue ;;  # Branch info line
      [AMDRCU]?) ((staged++)) ;;
      ?[MD]) ((unstaged++)) ;;
      "??") ((untracked++)) ;;
    esac
  done <<< "$git_status_raw"
  
  local stashed=$(git stash list 2>/dev/null | wc -l | tr -d ' ')

  # Detect GitHub by remote URL
  local remote_url=$(git config --get remote.origin.url 2>/dev/null)
  local upstream_url=$(git config --get remote.upstream.url 2>/dev/null)
  
  # Default Git text
  local host_text="git"
  
  # GitHub text if applicable
  [[ "$remote_url" == *github.com* || "$upstream_url" == *github.com* ]] && host_text="github"
  
  # Determine main git color (for git/github text and parentheses)
  local git_color="green"
  if [[ $((staged + unstaged + untracked + stashed)) -gt 0 ]]; then
    git_color="red"
  fi
  
  # Determine branch color (different from main git color)
  local branch_color="yellow"
  if [[ $((staged + unstaged + untracked + stashed)) -gt 0 ]]; then
    branch_color="magenta"
  fi

  # Determine sync (ahead/behind) info - removed sync icon for up-to-date repos
  local ahead behind sync_status=""
  if git rev-parse --abbrev-ref @{u} > /dev/null 2>&1; then
    local counts=$(git rev-list --left-right --count HEAD...@{u} 2>/dev/null)
    ahead=$(echo $counts | awk '{print $1}')
    behind=$(echo $counts | awk '{print $2}')
    
    if [[ $ahead -gt 0 && $behind -gt 0 ]]; then
      sync_status="${DIVERGED_ICON} ${ahead}/${behind}"
    elif [[ $ahead -gt 0 ]]; then
      sync_status="${AHEAD_ICON} ${ahead}"
    elif [[ $behind -gt 0 ]]; then
      sync_status="${BEHIND_ICON} ${behind}"
    fi
    # Removed the else clause that showed sync icon for up-to-date repos
  fi

  # Prepare status indicators with icons (no spaces between icon and number)
  local staged_status=""
  local unstaged_status=""
  local untracked_status=""
  local stashed_status=""
  
  [[ $staged -gt 0 ]] && staged_status="${STAGED_ICON}${staged}"
  [[ $unstaged -gt 0 ]] && unstaged_status="${UNSTAGED_ICON}${unstaged}"
  [[ $untracked -gt 0 ]] && untracked_status="${UNTRACKED_ICON}${untracked}"
  [[ $stashed -gt 0 ]] && stashed_status="${STASHED_ICON}${stashed}"

  # Return the git segment info for use in the prompt
  echo "${git_color}|${branch_color}|${host_text}|${branch}|${sync_status}|${staged_status}|${unstaged_status}|${untracked_status}|${stashed_status}"
}

# ─────────────────────────────────────────────────────────────
# Update prompt and Git info
# ─────────────────────────────────────────────────────────────
precmd() {
  export GIT_INFO=$(git_prompt_info)
  
  # Build the prompt
  build_prompt
}

# ─────────────────────────────────────────────────────────────
# Build the prompt with segments
# ─────────────────────────────────────────────────────────────
build_prompt() {
  # Start with a newline
  PROMPT=$'\n'
  
  # Directory segment in cyan
  PROMPT+="%F{cyan}%~%f"
  
  # Git segment if available
  if [[ -n "$GIT_INFO" ]]; then
    local git_parts=(${(s:|:)GIT_INFO})
    local git_color=${git_parts[1]}
    local branch_color=${git_parts[2]}
    local host_text=${git_parts[3]}
    local branch=${git_parts[4]}
    local sync_status=${git_parts[5]}
    local staged_status=${git_parts[6]}
    local unstaged_status=${git_parts[7]}
    local untracked_status=${git_parts[8]}
    local stashed_status=${git_parts[9]}
    
    # Add git segment with separate colors for git/parentheses and branch
    PROMPT+=" %F{$git_color}${host_text}(%F{$branch_color}${branch}%F{$git_color})"
    
    # Add sync status if available (no extra space since it's already formatted)
    [[ -n "$sync_status" ]] && PROMPT+=" ${sync_status}"
    
    # Add status indicators if available (in different colors for clarity)
    [[ -n "$staged_status" ]] && PROMPT+=" %F{green}${staged_status}%f"
    [[ -n "$unstaged_status" ]] && PROMPT+=" %F{yellow}${unstaged_status}%f"
    [[ -n "$untracked_status" ]] && PROMPT+=" %F{red}${untracked_status}%f"
    [[ -n "$stashed_status" ]] && PROMPT+=" %F{blue}${stashed_status}%f"
    
    # End git segment
    PROMPT+="%f"
  fi
  
  # Add newline and lambda prompt character for the second line
  PROMPT+=$'\n'"%F{blue}${PROMPT_CHAR}%f "
}

# Initialize the prompt
build_prompt

