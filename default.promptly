# allows cmd substitution in prompt
setopt prompt_subst

# ─────────────────────────────────────────────────────────────
# Lambda prompt character
# ─────────────────────────────────────────────────────────────
PROMPT_CHAR="❯"

# Define Nerd Font symbols with explicit Unicode values
GIT_ICON=$'\uf1d3'       # Git logo
GITHUB_ICON=$'\uf408'    # GitHub logo
BRANCH_ICON=$'\uf418'    # Branch icon
AHEAD_ICON=$'\uf062'     # Font Awesome solid arrow-up (better baseline alignment)
BEHIND_ICON=$'\uf175'    # Arrow down (behind)
DIVERGED_ICON=$'\uf7a5'  # Up/down arrows (diverged)
STAGED_ICON=$'+'         # Plus symbol (staged)
UNSTAGED_ICON=$'!'       # Exclamation symbol (unstaged)
UNTRACKED_ICON=$'?'      # Question mark symbol (untracked)
STASHED_ICON=$'$'        # Archive/box symbol (stashed)

# Cache for remote URL to avoid repeated git config calls
typeset -g _PROMPT_GIT_REMOTE_CACHE=""
typeset -g _PROMPT_GIT_REMOTE_CACHE_DIR=""

# ─────────────────────────────────────────────────────────────
# Git info function optimized for maximum performance
# ─────────────────────────────────────────────────────────────
git_prompt_info() {
  # Single git command to check if we're in a repo and get git dir
  local git_dir
  git_dir=$(git rev-parse --git-dir 2>/dev/null) || return
  
  # Get all git info in minimal calls
  local git_info branch_info
  
  # Combined git status and branch info in one call
  git_info=$(git status --porcelain=v1 -b --ahead-behind 2>/dev/null) || return
  
  # Parse branch info from first line
  local branch="" ahead=0 behind=0
  local first_line=${git_info%%$'\n'*}
  
  if [[ $first_line == "## "* ]]; then
    # Extract branch name and ahead/behind info
    branch_info=${first_line#"## "}
    
    if [[ $branch_info == *"..."* ]]; then
      # Has upstream
      local branch_part=${branch_info%%...*}
      local upstream_part=${branch_info#*...}
      branch=$branch_part
      
      # Parse ahead/behind from upstream part
      if [[ $upstream_part == *" [ahead "* ]]; then
        local ahead_part=${upstream_part#*" [ahead "}
        if [[ $ahead_part == *", behind "* ]]; then
          ahead=${ahead_part%%", behind "*}
          behind=${ahead_part#*", behind "}
          behind=${behind%"]"}
        else
          ahead=${ahead_part%"]"}
        fi
      elif [[ $upstream_part == *" [behind "* ]]; then
        local behind_part=${upstream_part#*" [behind "}
        behind=${behind_part%"]"}
      fi
    else
      # No upstream
      branch=$branch_info
    fi
  else
    # Fallback for detached HEAD
    branch=$(git describe --tags --exact-match 2>/dev/null || echo "DETACHED")
  fi
  
  # Count file statuses in single pass
  local staged=0 unstaged=0 untracked=0
  local status_lines=${git_info#*$'\n'}
  
  if [[ -n $status_lines ]]; then
    local line
    while IFS= read -r line; do
      case ${line:0:2} in
        [AMDRCU]?) ((staged++)) ;;
        ?[MD]) ((unstaged++)) ;;
        "??") ((untracked++)) ;;
      esac
    done <<< "$status_lines"
  fi
  
  # Get stash count only if needed (most repos don't have stashes)
  local stashed=0
  if [[ -f "$git_dir/refs/stash" ]]; then
    stashed=$(wc -l < "$git_dir/refs/stash" 2>/dev/null || echo 0)
  fi
  
  # Cache remote URL check to avoid repeated git config calls
  local host_icon="$GIT_ICON"
  if [[ "$_PROMPT_GIT_REMOTE_CACHE_DIR" != "$git_dir" ]]; then
    _PROMPT_GIT_REMOTE_CACHE_DIR="$git_dir"
    local remote_url
    remote_url=$(git config --get remote.origin.url 2>/dev/null)
    if [[ -z "$remote_url" ]]; then
      remote_url=$(git config --get remote.upstream.url 2>/dev/null)
    fi
    _PROMPT_GIT_REMOTE_CACHE="$remote_url"
  fi
  
  [[ "$_PROMPT_GIT_REMOTE_CACHE" == *github.com* ]] && host_icon="$GITHUB_ICON"
  
  # Determine color
  local git_color="green"
  [[ $((staged + unstaged + untracked + stashed)) -gt 0 ]] && git_color="red"
  
  # Build sync status
  local sync_status=""
  if [[ $ahead -gt 0 && $behind -gt 0 ]]; then
    sync_status="${DIVERGED_ICON}${ahead}/${behind}"
  elif [[ $ahead -gt 0 ]]; then
    sync_status="${AHEAD_ICON}${ahead}"
  elif [[ $behind -gt 0 ]]; then
    sync_status="${BEHIND_ICON}${behind}"
  fi
  
  # Build status indicators
  local staged_status="" unstaged_status="" untracked_status="" stashed_status=""
  [[ $staged -gt 0 ]] && staged_status="${STAGED_ICON}${staged}"
  [[ $unstaged -gt 0 ]] && unstaged_status="${UNSTAGED_ICON}${unstaged}"
  [[ $untracked -gt 0 ]] && untracked_status="${UNTRACKED_ICON}${untracked}"
  [[ $stashed -gt 0 ]] && stashed_status="${STASHED_ICON}${stashed}"
  
  echo "${git_color}|${host_icon}|${BRANCH_ICON}|${branch}|${sync_status}|${staged_status}|${unstaged_status}|${untracked_status}|${stashed_status}"
}

# ─────────────────────────────────────────────────────────────
# Update prompt and Git info
# ─────────────────────────────────────────────────────────────
precmd() {
  GIT_INFO=$(git_prompt_info)
  build_prompt
}

# ─────────────────────────────────────────────────────────────
# Build the prompt with segments
# ─────────────────────────────────────────────────────────────
build_prompt() {
  PROMPT=$'\n%F{cyan}%~%f'
  
  if [[ -n "$GIT_INFO" ]]; then
    local IFS='|'
    local git_parts=($GIT_INFO)
    
    PROMPT+=" %F{white}on%f %F{${git_parts[1]}}${git_parts[2]} ${git_parts[3]} ${git_parts[4]}"
    
    [[ -n "${git_parts[5]}" ]] && PROMPT+=" ${git_parts[5]}"
    [[ -n "${git_parts[6]}" ]] && PROMPT+=" %F{green}${git_parts[6]}%f"
    [[ -n "${git_parts[7]}" ]] && PROMPT+=" %F{yellow}${git_parts[7]}%f"
    [[ -n "${git_parts[8]}" ]] && PROMPT+=" %F{red}${git_parts[8]}%f"
    [[ -n "${git_parts[9]}" ]] && PROMPT+=" %F{blue}${git_parts[9]}%f"
    
    PROMPT+="%f"
  fi
  
  PROMPT+=$'\n%F{blue}'"${PROMPT_CHAR}"'%f '
}

# Initialize the prompt
build_prompt

